module SSH;

@load logging

export {
	# Create a new ID for our log stream
	#redef enum Logging::ID += { LOG_SSH };

	# Define a record with all the columns the log file can have.
	# (I'm using a subset of fields from ssh-ext for demonstration.)
	type Log: record {
		t: time;
		id: conn_id; # Will be rolled out into individual columns.
		status: string &optional;
		country: string &default="unknown";
	};
	
	# This is the prototype for the event that the logging framework tries
	# to generate if there is a handler for it.
	global log: event(rec: Log);
}

event bro_init()
{
	# Create the stream.
	# First argument is the ID for the stream.
	# Second argument is the log record type.
	Logging::create_stream("ssh", "SSH::Log");

	# Add a default filter that simply logs everything to "ssh.log" using the default writer.
	# Filtering is not implemented yet.  Waiting on ticket #367
	# Log line event generation is autogenerated for now by checking for 
	# handlers for MODULE_NAME::log
	#Logging::add_filter("ssh", [$name="default", $path="ssh"]);
	
	# Log something.
	Logging::log("ssh", [$t=network_time(),$status="ok\x00ok <	>"]);
	Logging::log("ssh", [$t=network_time(),$status="ok\x00ok <	>", $country="US"]);
	Logging::log("ssh", [$t=network_time(),$status="ok\x00ok <	>", $country="RU"]);
	Logging::log("ssh", [$t=network_time(),$status="ok\x00ok <	>", $country="RU"]);
	Logging::log("ssh", [$t=network_time(),$status="ok\x00ok <	>", $country="RU"]);
	
}

#event log(rec: Log)
#	{
#	print fmt("Ran the log handler from the same module.  Extracting time: %0.6f", rec$t);
#	}
#
#
#module WHATEVER;
#
#event SSH::log(rec: SSH::Log)
#	{
#	print fmt("Ran the SSH::log handler from a different module.  Extracting time: %0.6f", rec$t);
#	}